<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/bootstrap.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/bootstrap.ts" />
              <option name="originalContent" value="import {Application, Context, } from &quot;jsr:@oak/oak&quot;;&#10;import { oakCors } from &quot;https://deno.land/x/cors/mod.ts&quot;;&#10;import {load} from &quot;jsr:@std/dotenv&quot;;&#10;import {AppPolicyRegistry} from &quot;~/authorization/policy.authorization.ts&quot;;&#10;import {&#10;    buildRouter,&#10;    DefaultPolicyEngine,&#10;    DIContainer,&#10;    Logger,&#10;    LoggerMiddleware,&#10;    POLICY_ENGINE_TOKEN,&#10;    SwaggerMiddleware,&#10;    middlewareResolver,&#10;} from &quot;~/core/index.ts&quot;;&#10;import {initCore} from &quot;~/core/main.ts&quot;;&#10;import {DB} from &quot;~/db/db.ts&quot;;&#10;import {ErrorMiddleware, StaticMiddleware} from &quot;~/middleware/index.ts&quot;;&#10;import {JsonBodyMiddleware} from &quot;~/middleware/request-body-json-transformer.middleware.ts&quot;;&#10;&#10;/**&#10; * Controller imports (services and models get imported and created as needed)&#10; */&#10;import &quot;~/controllers/authentication.controller.ts&quot;;&#10;import &quot;~/controllers/users.controller.ts&quot;;&#10;&#10;export async function bootstrap() {&#10;    // Get environment variables&#10;    await load({envPath: &quot;./.env&quot;, export: true});&#10;&#10;    // Initialize core components (Dependency Injection, Logger, etc.)&#10;    initCore();&#10;&#10;    // We use the default policy engine with our app's policy registry&#10;    // This basically tells the @Authorize decorator how to decide who&#10;    // can access what.&#10;    // We still need to populate the context for the policy engine&#10;    // (i.e., ctx.state.user) in the authentication middleware, though&#10;    const policyEngine = new DefaultPolicyEngine(AppPolicyRegistry);&#10;    DIContainer.instance.register(POLICY_ENGINE_TOKEN, policyEngine);&#10;&#10;    // Initialize Oak App&#10;    const app = new Application();&#10;    // Build routes and instantiate controllers and their dependencies&#10;    const router = buildRouter();&#10;    // Set a port to listen to&#10;    const port = Number(Deno.env.get(&quot;PORT&quot;) ?? 8000);&#10;&#10;    try {&#10;        await DB.instance.pool.getConnection();&#10;        Logger.info(`✔️ DB connection pool created successfully`);&#10;    } catch (error) {&#10;        Logger.error(&quot;Database connection failed:&quot;, error);&#10;        await DB.instance.pool.end();&#10;        Deno.exit(1);&#10;    }&#10;&#10;    app.use(middlewareResolver(ErrorMiddleware));&#10;    app.use(middlewareResolver(LoggerMiddleware));&#10;    app.use(oakCors({&#10;        origin: &quot;http://localhost:4200&quot;,&#10;        credentials: true,&#10;        optionsSuccessStatus: 200,&#10;    }));&#10;    app.use(middlewareResolver(JsonBodyMiddleware));&#10;    app.use(router.routes());&#10;    app.use(router.allowedMethods());&#10;    Logger.info(&quot; All routes registered&quot;);&#10;    app.use(middlewareResolver(SwaggerMiddleware));&#10;    app.use(middlewareResolver(StaticMiddleware));&#10;&#10;    // Explicit 404 Fallback&#10;    app.use((ctx: Context) =&gt; {&#10;        ctx.response.status = 404;&#10;        ctx.response.body = {error: &quot;Not Found&quot;};&#10;        Logger.warn(`Not Found: ${ctx.request.method} ${ctx.request.url}`);&#10;    });&#10;&#10;    Logger.info(Logger.separator);&#10;&#10;    try {&#10;        Logger.info(` Server running on http://localhost:${port}`);&#10;        await app.listen({port});&#10;    } catch (error: unknown) {&#10;        Logger.error(`The server encountered an unhandled error: ${error}`);&#10;    } finally {&#10;        Logger.info(&quot;Server shutting down&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import {Application, Context, } from &quot;jsr:@oak/oak&quot;;&#10;import { oakCors } from &quot;https://deno.land/x/cors/mod.ts&quot;;&#10;import {load} from &quot;jsr:@std/dotenv&quot;;&#10;import {AppPolicyRegistry} from &quot;~/authorization/policy.authorization.ts&quot;;&#10;import {&#10;    buildRouter,&#10;    DefaultPolicyEngine,&#10;    DIContainer,&#10;    Logger,&#10;    LoggerMiddleware,&#10;    POLICY_ENGINE_TOKEN,&#10;    SwaggerMiddleware,&#10;    middlewareResolver,&#10;} from &quot;~/core/index.ts&quot;;&#10;import {initCore} from &quot;~/core/main.ts&quot;;&#10;import {DB} from &quot;~/db/db.ts&quot;;&#10;import {ErrorMiddleware, StaticMiddleware} from &quot;~/middleware/index.ts&quot;;&#10;import {JsonBodyMiddleware} from &quot;~/middleware/request-body-json-transformer.middleware.ts&quot;;&#10;&#10;/**&#10; * Controller imports (services and models get imported and created as needed)&#10; */&#10;import &quot;~/controllers/authentication.controller.ts&quot;;&#10;import &quot;~/controllers/users.controller.ts&quot;;&#10;&#10;export async function bootstrap() {&#10;    // Get environment variables&#10;    await load({envPath: &quot;./.env&quot;, export: true});&#10;&#10;    // Initialize core components (Dependency Injection, Logger, etc.)&#10;    initCore();&#10;&#10;    // We use the default policy engine with our app's policy registry&#10;    // This basically tells the @Authorize decorator how to decide who&#10;    // can access what.&#10;    // We still need to populate the context for the policy engine&#10;    // (i.e., ctx.state.user) in the authentication middleware, though&#10;    const policyEngine = new DefaultPolicyEngine(AppPolicyRegistry);&#10;    DIContainer.instance.register(POLICY_ENGINE_TOKEN, policyEngine);&#10;&#10;    // Initialize Oak App&#10;    const app = new Application();&#10;    // Build routes and instantiate controllers and their dependencies&#10;    const router = buildRouter();&#10;    // Set a port to listen to&#10;    const port = Number(Deno.env.get(&quot;PORT&quot;) ?? 8000);&#10;&#10;    try {&#10;        await DB.instance.pool.getConnection();&#10;        Logger.info(`✔️ DB connection pool created successfully`);&#10;    } catch (error) {&#10;        Logger.error(&quot;Database connection failed:&quot;, error);&#10;        await DB.instance.pool.end();&#10;        Deno.exit(1);&#10;    }&#10;&#10;    app.use(middlewareResolver(ErrorMiddleware));&#10;    app.use(middlewareResolver(LoggerMiddleware));&#10;    app.use(oakCors({&#10;        origin: &quot;http://localhost:4200&quot;,&#10;        credentials: true,&#10;        optionsSuccessStatus: 200,&#10;    }));&#10;    app.use(middlewareResolver(JsonBodyMiddleware));&#10;    app.use(router.routes());&#10;    app.use(router.allowedMethods());&#10;    Logger.info(&quot; All routes registered&quot;);&#10;    app.use(middlewareResolver(SwaggerMiddleware));&#10;    app.use(middlewareResolver(StaticMiddleware));&#10;&#10;    // Explicit 404 Fallback&#10;    app.use((ctx: Context) =&gt; {&#10;        ctx.response.status = 404;&#10;        ctx.response.body = {error: &quot;Not Found&quot;};&#10;        Logger.warn(`Not Found: ${ctx.request.method} ${ctx.request.url}`);&#10;    });&#10;&#10;    Logger.info(Logger.separator);&#10;&#10;    try {&#10;        Logger.info(` Server running on http://localhost:${port}`);&#10;        await app.listen({port});&#10;    } catch (error: unknown) {&#10;        Logger.error(`The server encountered an unhandled error: ${error}`);&#10;    } finally {&#10;        Logger.info(&quot;Server shutting down&quot;);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>